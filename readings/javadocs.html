<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>Documentation and Testing
  (COURSE ID)
</title><link rel="stylesheet" href="../resources/stylesheet.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.73.2"></head><body style="background-image:url(../Images/logo.png);"><p xmlns="http://www.w3.org/TR/xhtml1/transitional" class="course">
  The New Tao of Java
<br></br><a name="body"></a></p><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="NOPRINT"><p class="links">
[<a href="#body">Skip to Body</a>]
</p><p class="links"><b>Sections:</b> [<a href="../assignments/">Assignments</a>] [<a href="../examples/">Examples</a>] [<a href="../handouts/">Handouts</a>] [<a href="../readings/">Readings</a>]
</p><p class="links"><b>Reference:</b> [<a href="http://docs.oracle.com/javase/7/docs/api/">Java 7 API</a>]
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h1 xmlns="http://www.w3.org/TR/xhtml1/transitional">Documentation and Testing</h1></div></div><hr></div><p>
  <span class="emphasis"><em>Summary:</em></span>
  We consider the various forms of documentation that programmers typically write and read and examine
  Javadoc, Java's tool for generating documentation for client programmers.
</p><div class="section" lang="en"><div class="titlepage"></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 xmlns="http://www.w3.org/TR/xhtml1/transitional">Forms of Documentation</h3></div></div></div><p>
  Even though you are a comparatively novice programmer, you have likely learned the importance of   
  documenting your work (or, as importantly, of others documenting their work). When you use a program,
  such as Emacs, it helps to have documentation that lets you quickly identify how to do particular
  activities. When you use a Java class that comes as part of the standard installation, such as 
  <code class="code">java.io.PrintWriter</code>, you hope to have clear instructions on how to build and use objects
  in that class. When you're writing a method, it helps to have a short note as to what you expect the 
  method to do. It may also help to have some notes as to the steps in your algorithm. (As a professor,
  I find it much easier to help my students when they have documentation that explains what they intended 
  the method to do and how the code they've written is supposed to accomplish this task.) Finally, when you 
  modify the code of others (Or even your own code a few months later), it helps to have similar 
  explanations: What were you trying to do and how were you trying to do it? You can probably suggest other 
  ways that you document your code.
</p><p>
  It helps to classify this wide variety of kinds of documentation into three audiences:
</p><div class="itemizedlist"><ul type="disc"><li><span class="emphasis"><em>Users</em></span>, who consult the documentation when attempting to use your program. 
    Although in the real world, programmers are not necessarily expected to provide this kind of
    documentation, you will often have to provide it earlier in your programming career and it helps 
    to remember that <span class="emphasis"><em>someone</em></span> has to write such documentation. 
  </li><li><span class="emphasis"><em>Client Programmers</em></span>, who use the classes you design, often in new contexts.
  </li><li><span class="emphasis"><em>Colleagues</em></span>, who must support and update your code.
  </li></ul></div><p>
  In this document, we will focus primarily on the documentation you write for other programmers, both
  client programmers and colleagues.
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 xmlns="http://www.w3.org/TR/xhtml1/transitional">Documenting at Many Levels</h3></div></div></div><p>
  One of the first things you should observe as you write documentation for other programmers is that 
  there are many levels of documentation you need to write, particularly if you're providing a host of
  classes for client or colleague (or yourself).
</p><p>
  You should begin with a <span class="emphasis"><em>package-level overview</em></span> of the various classes and objects 
  and the relationships they play with each other. Such an overview helps guide your colleagues to the right
  place to find something and guides your clients as to what classes they need for different purposes and 
  how they interact. As a client, you may have found such high-level overviews useful for figuring out how 
  things go together. Experience suggests that high-level overviews are strengthened by sample code, but you 
  often don't want to write that code until after you've written a few programs using your package or 
  packages yourself.
</p><p>
  Next, you should provide a <span class="emphasis"><em>class-level overview</em></span> of each class or interface you write. 
  Like the package-level overview, it guides your reader as to how things fit together and where things can 
  be found. Such overviews might also include code.
</p><p>
  Third, you should write <span class="emphasis"><em>method and field summaries</em></span> that provide details about the 
  individual fields, methods, and constructors of your classes. Typically, a field summary provides 
  information about the intended use of the field and any special values it may take on. (For example, 
  some programs use 0 or -1 to indicate a special situation.) The summary for a method or constructor 
  should provide coherent information about the purpose of the method. We revisit the form and content 
  of this summary in a subsequent section.
</p><p>
  Finally, within each method, you document the intended meaning of each step.
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 xmlns="http://www.w3.org/TR/xhtml1/transitional">When to Document?</h3></div></div></div><p>
  Many programmers seem unsure of when they should write their documentation. The answer is easy: you 
  should <span class="emphasis"><em>Document Early and Often</em></span>. By early, I mean that you should write most of 
  your documentation <span class="emphasis"><em>before</em></span> you begin to code. You may have to go back and modify 
  your comments later, perhaps as you realize that you can't meet your intent, but early documentation 
  helps guide you when you've forgotten what you want to do (and helps others help you).
</p><p>
  Let's consider an example: How might we document and then write a procedure for exponentiation? I begin 
  with a full statement of what I expect the algorithm to compute.
</p><pre class="programlisting"> 
  /**
  * Given an integer, x, and an exponent, p, compute x^p.
  *
  * @param x
  *   an integer
  * @param p
  *   a whole number
  * @pre
  *   x must be non-negative.
  *   x^p must be smaller than the largest representable integer.
  * @post
  *   The result = x*x*x* ... *x (p times)
  */
</pre><p>
  Next, we write a short summary of the algorithm or any other issues of import.
</p><pre class="programlisting"> 
  /*
   * Algorithm: We rely on the rules that
   *   x^0 = 1
   *   x^k+1 = x^k*x
   *   x^2k = (x^k)^2
   */
</pre><p>
  Finally, we write the body with short comments of what I intend to do.
</p><pre class="programlisting"> 
  public int exp(int x, int p)
  {
   // Base case: When p = 0, result is 1
   // Base case: When p = 1, result is x
   // Recursive case: When p is odd, result is x*(x^(p-1))
   // Recursive case: When p is even, result is x^(p^2) square
  } // exp(int, int)
</pre><p>
  Only once that infrastructure is in place do we begin coding.
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 xmlns="http://www.w3.org/TR/xhtml1/transitional">Documenting Methods</h3></div></div></div><p>
  As you may have noted from the above, there are a variety of things one can mention when documenting a
  method (or constructor). Let&#8217;s call them the Five P&#8217;s.
</p><div class="itemizedlist"><ul type="disc"><li><span class="emphasis"><em>Purpose:</em></span> Summarize what the method does in a sentence or two (or three or four).
  </li><li><span class="emphasis"><em>Parameters:</em></span> Describe the name, type, and possibly role of the parameters.
  </li><li><span class="emphasis"><em>Produces:</em></span> Describe the type of the result. It may also be helpful to name it.
  </li><li><span class="emphasis"><em>Preconditions:</em></span> A formal (or somewhat formal) specification of what must hold in 
    order for the method to work.
  </li><li><span class="emphasis"><em>Postconditions:</em></span> A formal (or somewhat formal) specification of the results. You 
    should think of the purpose as giving an informal specification and the postconditions as giving a more 
    formal specification.
  </li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 xmlns="http://www.w3.org/TR/xhtml1/transitional">What are Javadocs?</h3></div></div></div><p>
  Javadoc is a documentation generator from Oracle. It transforms the documentation we give each method and
  generates a nice, uniformly formatted HTML output. We call the actual comments we put in Eclipse to   
  document our code <span class="emphasis"><em>Doc Comments</em></span>. We can document pretty much everything for any method with them. Doc Comments tell us what each parameter does, what the method returns, and if it throws any exceptions (they handle errors in specific cases). 
</p><p>
  Here&#8217;s an example of Javadoc documentation in action.
</p><p>
  <span class="emphasis"><em><img src="../images/Javadoc1.png"></em></span> 
</p><p>
  To create Doc Comments you need to preface them with <code class="code">/**</code> and end with <code class="code">*/</code>
  This will turn the comments blue. 
</p><p>
  One odd aspect of Javadoc is that you indicate special aspects of your documentation with tags that begin 
  with an at sign. In the sample above, you see <code class="code">@pre</code>, <code class="code">@post</code>, and 
  <code class="code">@param</code>. Other important tags include:
</p><div class="itemizedlist"><ul type="disc"><li><code class="code">@author</code> - the author of the class. This should only be included in the Javadoc comment for 
    the whole class
  </li><li><code class="code">@version</code> - the version of the class (date). As above, only include in the Javadoc comment 
    for the whole class
  </li><li><code class="code">@return</code> - what the method returns and its type
  </li><li><code class="code">@exception NameOfException</code> - when and why the method throws that exception
  </li></ul></div><p>
  In our example, we've included <code class="code">@pre</code> and <code class="code">@post</code>.  These are custom tags that we 
  must create on our own in Eclipse. To do this, we write our Javadocs with <code class="code">@pre</code> and 
  <code class="code">@post</code> added as shown. With our project or class (for which we want to generate the Javadoc) 
  highlighted, we go to <span class="guimenu">Project</span> <span class="guimenuitem"> &gt; Generate Javadoc...</span>. We 
  make sure that we&#8217;re generating the Javadoc for the right document. Normally we would just click Finish 
  and let Eclipse do its job, but this first time we want to click Next and Next again.
</p><p>
  Under Extra Javadoc Options we want to enter:
</p><div class="literallayout"><p> <br>
<strong class="userinput"><code> <br>
  -tag pre:cm:"Preconditions:"<br>
  -tag post:cm:"Postconditions:"<br>
</code></strong><br>
</p></div><p>
  <span class="emphasis"><em><img src="../images/Javadoc2.png"></em></span> 
</p><p>
  A popup window will appear. Select Yes To All and make the Ant File when it prompts you for one. You&#8217;ve 
  successfully created a Javadoc!  To see the Javadoc in a web browser, go to <span class="guimenu">Navigate</span> &gt; 
  <span class="guimenuitem">Open Attached Javadoc</span> 
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 xmlns="http://www.w3.org/TR/xhtml1/transitional">A More Indepth Example</h3></div></div></div><p>
  Since we haven&#8217;t written long and elaborate code yet, you might not see how useful Javadoc can really be.  
  Let&#8217;s look at a larger project we&#8217;ll work on later in the semester. 
</p><p>
  <span class="emphasis"><em><img src="../images/Javadoc3.png"></em></span> 
</p><p>
  <span class="emphasis"><em><img src="../images/Javadoc4.png"></em></span> 
</p><p>
  The package list presents us with an overview of all the classes in the package and links to each of 
  those classes&#8217; documentation.
</p><p>
  Here&#8217;s an example of how the documentation looks like for the DoublyLinkedList.
</p><p>
  <span class="emphasis"><em><img src="../images/Javadoc5.png"></em></span> 
</p><p>
  <span class="emphasis"><em><img src="../images/Javadoc6.png"></em></span> 
</p><p>
  It looks like a less polished version of the <a class="ulink" href="http://docs.oracle.com/javase/7/docs/api/" target="_top">
  Java API</a>, but the skeleton is the same.
</p></div></div><div class="section" lang="en"><div class="titlepage"></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 xmlns="http://www.w3.org/TR/xhtml1/transitional">Unit Testing</h3></div></div></div><p>
  Unit testing is a method that is used to test individual pieces of source code. This method is a powerful 
  tool for helping you test complicated code by breaking it into smaller and more easily understood pieces. 
  In order to unit test in Java, we use a framework called JUnit.
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 xmlns="http://www.w3.org/TR/xhtml1/transitional">How We Do It</h3></div></div></div><p>
  In order to use JUnit in eclipse, right click the class that we want to test then choose 
  <span class="guimenu">New</span> &gt;<span class="guimenuitem">JUnit Test Case</span>. This will open the New JUnit Test   
  Case window. Once there, hit the Next button. After that you will have the <span class="guimenu">Test Methods</span> 
  menu open. This menu will have the class that you chose as the first option. Underneath, it will have all 
  of the methods in your class that you can test. Pick the methods that you want to test and hit the Finish 
  button, and Eclipse will create a new class within the same package that you can use for testing. For 
  reference, you usually won&#8217;t have to test the <code class="methodname">constructor</code> method or the 
  <code class="methodname">toString</code> method.
</p><p>
  Within the class that you just made, there will be methods that are prefixed with test. These are what you 
  will use to test each method you have chosen. At the moment they all should have:
</p><pre class="programlisting">
  fail("Not yet implemented");
</pre><p>
  We will replace this code with test code, of which we have a variety to choose from:
</p><div class="itemizedlist"><ul type="disc"><li><code class="methodname">assertEquals()</code></li><li><code class="methodname">assertTrue()</code> and <code class="methodname">assertFalse()</code></li><li><code class="methodname">assertNull()</code> and <code class="methodname">assertNotNull()</code></li><li><code class="methodname">assertSame()</code> and <code class="methodname">assertNotSame()</code></li><li><code class="methodname">assertArrayEquals()</code></li><li><code class="methodname">fail()</code></li></ul></div><p>
  It should be noted that there are more methods that can be used in JUnit than just these few, though the   
  most commonly used method is <code class="methodname">assertEquals()</code>. We can use as many of these tests as 
  we need within a single method, but when we run our code, JUnit will only tell us if our method as a whole 
  passed. If JUnit reports that the method has failed, it means that a test within the method we&#8217;re testing 
  failed. It will tell you the location of the first test that our code did not pass. Note that JUnit will 
  stop at the first test that our code does not pass.
</p><p>
 For example, we want to test this class:
</p><pre class="programlisting"> 
package jUnit;

public class Example {

    /*An array of integers with factorial of 1 in the index 0.*/
    static int[] factorials = new int[100];

   

/**
 * @param number
 *  a positive number that is larger than 0 and less then 100
 * @return
 *  the factorial of the parameter
 * @pre
 *  factorial() will compute the factorial of a given number between 0 and 100, 
 *  not inclusive. The given number must be an integer.
 * @post
 *     factorial() will return a positive integer that will represent that factorial 
 *     of a given number. If factorial() is given a number that is outside of the predefined 
 *     range, 0-100, it will throw an ArrayIndexOutOfBoundsException.
 */

    public static int factorial(int number) {

        if(number == 1){

            factorials[0] = 1;

            return 1;

        } // if       

        if(factorials[number] == 0){

            factorials[number -1] = number * factorial(number - 1);

        } // if 

        return factorials[number -1];

    } // factorial(int number)

/**
* @param number
*  any integer, if the number is a double the method will fail
* @return
*  isEven() will return true if the given number is even and false if it is odd 
*  In the case of 0, it will return true
*/

    public static boolean isEven(int number) {

        if(number % 2 ==0)

            return true;

        else

            return false;

    } // isEven(int number)

   
} // Example
</pre><p>
  This is out JUnit Test Case class:
</p><pre class="programlisting">
package jUnit;

import static org.junit.Assert.*;

import org.junit.Test;

public class ExampleTest {

    @Test

    public void testFactorial() {

        assertEquals(6, Example.factorial(3));

        assertNotSame(5, Example.factorial(5));

        assertEquals(Example.factorial(5), Example.factorial(5));

    } // testFactorial()
} // ExampleTest
</pre><p>
  In order to use the <code class="methodname">factorial()</code> method from the Example class, we have to treat 
  it as a library and prefix the method <code class="methodname">isEven</code> with the library that it comes from. 
  In Java, we do this by putting a period between the library and method. This code will work perfectly if 
  we were to run it, but what if we wanted to test more than one method at a time? We could do this by 
  either making a new JUnit test case or by adding a <code class="methodname">testIsItFive()</code> method. However 
  if we were to add this:
</p><pre class="programlisting">
  public void testIsEven() {
    assertTrue(Example.isEven(6));
  } // testIsEven()
</pre><p>
JUnit would not tell us if the method passed, but would only tell us if the <code class="methodname">testFactorial()</code> method passed. In order to make sure JUnit also tests this new method, we need to write <code class="code">@Test</code> on the line above it. In fact, all of the methods that we want JUnit to test must be marked with <code class="code">@Test</code> in order for JUnit to run through them all. 
</p><p>
Make sure that you are aware that any operation within a method will not affect the operations within another method. An example of this is if we had an empty list and added an element to it within the method testA, and then tried to get the first element of the same list within the method testB we would find that there is nothing in the list. 
</p><p>
Obviously this feature of JUnit, poses a problem. One way that we can sidestep this feature is by declaring a global variable or by using the setUp() method. This method prefixed with @Before, will fix that problem. The prefix @Before will run the setUp() method before each test, so if we want each of our methods to refer to a non-empty list, we can add it within setUp(). Generally, whatever we put in setUp() will hold true for every other test method. The first time you use @Before, Eclipse will underline it red. Hover over it and import &#8216;Before&#8217; (org.junit).
</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 xmlns="http://www.w3.org/TR/xhtml1/transitional">Important Terms</h2></div></div></div><div class="itemizedlist"><ul type="disc"><li>
    Javadoc
  </li><li>
    Javadoc tags
  </li><li>
    Java API
  </li><li>
    Unit Testing
  </li><li>
    JUnit
  </li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 xmlns="http://www.w3.org/TR/xhtml1/transitional">Review Questions</h2></div></div></div><div class="orderedlist"><ol type="1"><li>
    Why would one create their own Javadoc tags? What are some tags that you think would be useful?
  </li><li>
    Why is it better to document your code before you implement it?
  </li><li>
    Why do we document our code?
  </li><li>
    How can we automatically generate Doc Comments when we create a class?
  </li><li>
    Why is it better to write test suits, than testing our code with a bunch of print statements?
  </li><li>
    How do we enter JUnit?
  </li></ol></div></div></div><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="foot"><div class="NOPRINT"><hr></hr><div class="NOPRINT"><p class="links">
[<a href="#body">Skip to Body</a>]
</p><p class="links"><b>Sections:</b> [<a href="../assignments/">Assignments</a>] [<a href="../examples/">Examples</a>] [<a href="../handouts/">Handouts</a>] [<a href="../readings/">Readings</a>]
</p><p class="links"><b>Reference:</b> [<a href="http://docs.oracle.com/javase/7/docs/api/">Java 7 API</a>]
</p></div><div class="pagenotes"><p><a rel="license" href="http://creativecommons.org/licenses/by-nc/2.5/"><img alt="Creative Commons License" style="border-width: 0" src="http://creativecommons.org/images/public/somerights20.png"></img></a></p></div></div><div class="pagenotes"><p>
Copyright (c) 2013 Samuel A. Rebelsky and the Glimmer '13 team.
</p><p>
This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc/2.5/">Creative Commons
Attribution-NonCommercial 2.5  License</a>.  To view a copy of this
license, visit <a href="http://creativecommons.org/licenses/by-nc/2.5/"><code>http://creativecommons.org/licenses/by-nc/2.5/</code></a> 
or send a letter to Creative Commons, 543 Howard Street, 5th Floor, 
San Francisco, California, 94105, USA.
</p></div></div></body></html>
